r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of user-controlled strings in eval
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # dangerous use of ObjectGraphNavigation
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // server-side expression execution from request
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsafe use of eval/template functions
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of code execution libraries on user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of user-controlled strings in eval
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of user-controlled strings in eval
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # server-side expression execution from request
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // dangerous use of ObjectGraphNavigation
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // server-side expression execution from request
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsanitized EL evaluation from user input
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsafe use of eval/template functions
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of code execution libraries on user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // injection into template rendering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # use of user-controlled strings in eval
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # expression parsing without filtering
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // expression parsing without filtering
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // use of code execution libraries on user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // injection into template rendering
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // expression parsing without filtering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // server-side expression execution from request
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // injection into template rendering
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // unsanitized EL evaluation from user input
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // dangerous use of ObjectGraphNavigation
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // use of code execution libraries on user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // use of user-controlled strings in eval
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // expression parsing without filtering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of code execution libraries on user input
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # use of user-controlled strings in eval
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsafe use of eval/template functions
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // expression parsing without filtering
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsanitized EL evaluation from user input
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # injection into template rendering
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # unsanitized EL evaluation from user input
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsafe use of eval/template functions
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsanitized EL evaluation from user input
    res.send("Result: " + result);
});
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # dangerous use of ObjectGraphNavigation
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // expression parsing without filtering
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // unsanitized EL evaluation from user input
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
@app.route('/eval')
def evaluate():
    expr = request.args.get('expr')
    return str(eval(expr))  # unsafe use of eval/template functions
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // dangerous use of ObjectGraphNavigation
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // injection into template rendering
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of user-controlled strings in eval
    res.send("Result: " + result);
});
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // use of code execution libraries on user input
    res.send("Result: " + result);
});
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # server-side expression execution from request
    return HttpResponse(f"Result: {result}")
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // server-side expression execution from request
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public IActionResult Eval(string expr) {
    var scriptOptions = ScriptOptions.Default;
    var result = CSharpScript.EvaluateAsync(expr, scriptOptions).Result;  // unsafe use of eval/template functions
    return Ok("Result: " + result.ToString());
}
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # expression parsing without filtering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // unsanitized EL evaluation from user input
    return response("Result: " . \$result);
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // dangerous use of ObjectGraphNavigation
    res.send("Result: " + result);
});
--valknut--satty--
public function evalCode(Request $request) {
    $expr = $request->input('expr');
    eval("\$result = $expr;");  // use of code execution libraries on user input
    return response("Result: " . \$result);
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // dangerous use of ObjectGraphNavigation
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
@GetMapping("/eval")
public String evaluate(@RequestParam String expr) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression(expr);  // server-side expression execution from request
    return "Result: " + exp.getValue().toString();
}
--valknut--satty--
app.get('/eval', function(req, res) {
    const expr = req.query.expr;
    const result = eval(expr);  // unsafe use of eval/template functions
    res.send("Result: " + result);
});
--valknut--satty--
r.GET("/eval", func(c *gin.Context) {
    expr := c.Query("expr")
    result, _ := govaluate.NewEvaluableExpression(expr)  // injection into template rendering
    val, _ := result.Evaluate(nil)
    c.String(200, fmt.Sprintf("Result: %v", val))
})
--valknut--satty--
def eval_view(request):
    expr = request.GET.get('expr')
    result = eval(expr)  # injection into template rendering
    return HttpResponse(f"Result: {result}")
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # string interpolation with user data
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # string interpolation with user data
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // dynamic expression parsing
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // template injection with user input
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // remote code execution via template
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled input in eval
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // template injection with user input
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // dynamic expression parsing
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled input in eval
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // string interpolation with user data
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsafe template evaluation
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // dynamic expression parsing
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # template injection with user input
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled logic evaluation
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsafe template evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // template injection with user input
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // dynamic expression parsing
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // remote code execution via template
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // code injection via dynamic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // unsanitized input passed to template engine
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsanitized input passed to template engine
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # template injection with user input
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // user-controlled logic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled logic evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // expression execution from request
    return Ok(result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // expression execution from request
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled input in eval
    return response($result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // code injection via dynamic evaluation
    return exp.getValue(String.class);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsafe template evaluation
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsafe template evaluation
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // code injection via dynamic evaluation
    res.send(result);
});
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # code injection via dynamic evaluation
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled logic evaluation
    res.send(result);
});
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # remote code execution via template
    return HttpResponse(result)
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // code injection via dynamic evaluation
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
# Unsupported framework
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // string interpolation with user data
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # remote code execution via template
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # unsafe template evaluation
    return HttpResponse(result)
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // remote code execution via template
    return exp.getValue(String.class);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // dynamic expression parsing
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // user-controlled logic evaluation
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled input in eval
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // user-controlled input in eval
    res.send(result);
});
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
@GetMapping("/greet")
public String greet(@RequestParam String name) {
    ExpressionParser parser = new SpelExpressionParser();
    Expression exp = parser.parseExpression("'Hello ' + name");  // expression execution from request
    return exp.getValue(String.class);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // template injection with user input
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // unsafe template evaluation
    c.String(200, result.(string))
})
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // expression execution from request
    c.String(200, result.(string))
})
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // user-controlled input in eval
    c.String(200, result.(string))
})
--valknut--satty--
# Unsupported framework
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // remote code execution via template
    return response($result);
}
--valknut--satty--
r.GET("/greet", func(c *gin.Context) {
    name := c.Query("name")
    expr := "'Hello ' + " + name
    expression, _ := govaluate.NewEvaluableExpression(expr)
    result, _ := expression.Evaluate(nil)  // string interpolation with user data
    c.String(200, result.(string))
})
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # expression execution from request
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // unsanitized input passed to template engine
    return response($result);
}
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsanitized input passed to template engine
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // expression execution from request
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # dynamic expression parsing
    return HttpResponse(result)
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // string interpolation with user data
    return Ok(result);
}
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # expression execution from request
    return HttpResponse(result)
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // remote code execution via template
    res.send(result);
});
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // string interpolation with user data
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # dynamic expression parsing
--valknut--satty--
def greet(request):
    name = request.GET.get('name')
    result = eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
    return HttpResponse(result)
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // template injection with user input
    return response($result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # user-controlled logic evaluation
--valknut--satty--
public function greet(Request $request) {
    $name = $request->input('name');
    $result = eval("return 'Hello ' . \$name;");  // code injection via dynamic evaluation
    return response($result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
# Unsupported framework
--valknut--satty--
app.get('/greet', function(req, res) {
    const name = req.query.name;
    const result = eval("'Hello ' + name");  // unsafe template evaluation
    res.send(result);
});
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // user-controlled input in eval
    return Ok(result);
}
--valknut--satty--
@app.route('/greet')
def greet():
    name = request.args.get('name')
    return eval(f"'Hello ' + {name}")  # unsanitized input passed to template engine
--valknut--satty--
public IActionResult Greet(string name) {
    var expression = "'Hello ' + " + name;
    var result = CSharpScript.EvaluateAsync<string>(expression).Result;  // unsanitized input passed to template engine
    return Ok(result);
}